(in-ns 'timl.core)

(defmacro lazy-seq [& body]
  (list '#*timl#lazy_seq#create (cons 'fn* (cons [] body))))

(defmacro let [& args] (cons 'let* args))

(defn concat
  ([] (lazy-seq nil))
  ([x] (lazy-seq x))
  ([x y]
    (lazy-seq
      (let [s (seq x)]
        (if s
          (if (chunked-seq? s)
            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))
            (cons (first s) (concat (rest s) y)))
          y))))
  ([x y & zs]
     (let [cat (fn cat [xys zs]
                 (lazy-seq
                   (let [xys (seq xys)]
                     (if xys
                       (if (chunked-seq? xys)
                         (chunk-cons (chunk-first xys) (cat (chunk-rest xys) zs))
                         (cons (first xys) (cat (rest xys) zs)))
                       (if zs
                         (cat (first zs) (next zs)))))))]
       (cat (concat x y) zs))))

(defmacro defn- [name & fdecl]
  `(defn ~(with-meta name (assoc (meta name) :private true)) ~@fdecl))

(defmacro deftype [name slots & more]
  `(let [type# (deftype* ~name ~slots)]
     type#))

(defmacro when [test & body]
  `(if ~test (do ~@body)))

(defmacro if-let [bindings then & else]
  (let [form (first bindings)
        tst (first (rest bindings))]
    `(let [temp# ~tst]
      (if temp#
        (let [~form temp#] ~then) ~@else))))

(defmacro when-let [bindings & body]
  (let [form (first bindings)
        tst (first (rest bindings))]
    `(let [temp# ~tst]
      (if temp#
        (let [~form temp#] ~@body)))))

(defmacro or
  ([] nil)
  ([x] x)
  ([x & xs] `(let [or# ~x] (if or# or# (or ~@xs)))))

(defmacro and
  ([] true)
  ([x] x)
  ([x & xs] `(let [and# ~x] (if and# (and ~@xs) and#))))

(defmacro cond [& clauses]
  (when (seq clauses)
    (list 'if (first clauses)
          (first (rest clauses))
          (cons `cond (rest (rest clauses))))))

(defn every?
  [pred coll]
  (cond
   (nil? (seq coll)) true
   (pred (first coll)) (recur pred (next coll))
   :else false))

(defn map 
  ([f coll]
   (lazy-seq
     (when-let [s (seq coll)]
               (if (can? s chunk-first)
                 (concat
                   (#*timl#coll#mutating_map f (chunk-first s))
                   (map f (chunk-rest s)))
                 (cons (f (first s)) (map f (rest s)))))))
  ([f c1 c2]
   (lazy-seq
    (let [s1 (seq c1) s2 (seq c2)]
      (when (and s1 s2)
        (cons (f (first s1) (first s2))
              (map f (rest s1) (rest s2)))))))
  ([f c1 c2 c3]
   (lazy-seq
    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]
      (when (and  s1 s2 s3)
        (cons (f (first s1) (first s2) (first s3))
              (map f (rest s1) (rest s2) (rest s3)))))))
  ([f c1 c2 c3 & colls]
   (let [step (fn step [cs]
                 (lazy-seq
                  (let [ss (map seq cs)]
                    (when (every? identity ss)
                      (cons (map first ss) (step (map rest ss)))))))]
     (map #(apply f %) (step (conj colls c3 c2 c1))))))

(defmacro -> [x & forms]
  (if (seq forms)
    (let [form (first forms)
          more (next forms)] (if more `(-> (-> ~x ~form) ~@more) (if (list? form)
          `(~(first form) ~x ~@(rest form))
          (list form x))))
    x))

(defn mapv
  ([f coll]
     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)
         persistent!))
  ([f c1 c2]
     (into [] (map f c1 c2)))
  ([f c1 c2 c3]
     (into [] (map f c1 c2 c3)))
  ([f c1 c2 c3 & colls]
     (into [] (apply map f c1 c2 c3 colls))))

(defn dorun
  ([coll]
   (when (seq coll)
     (if (chunked-seq? coll)
       (recur (chunk-rest coll))
       (recur (next coll)))))
  ([n coll]
   (when (and (seq coll) (pos? n))
     (recur (dec n) (next coll)))))

(defn doall
  ([coll]
   (dorun coll)
   coll)
  ([n coll]
   (dorun n coll)
   coll))

(defn nthrest [coll n]
  (if (and (pos? n) (seq coll))
    (recur (rest coll) (dec n))
    coll))

(defn take [n coll]
  (lazy-seq
    (when (pos? n)
      (when-let [s (seq coll)]
        (cons (first s) (take (dec n) (rest s)))))))

(defn drop
  [n coll]
  (let [step (fn [n coll]
              (if-let [s (seq coll)]
                (if (pos? n)
                  (recur (dec n) (rest s))
                  s)))]
    (lazy-seq (step n coll))))

(defn partition
  ([n coll]
   (partition n n coll))
  ([n step coll]
   (lazy-seq
     (when-let [s (seq coll)]
       (let [p (doall (take n s))]
         (when (= n (count p))
           (cons p (partition n step (nthrest s step))))))))
  ([n step pad coll]
   (lazy-seq
     (when-let [s (seq coll)]
       (let [p (doall (take n s))]
         (if (= n (count p))
           (cons p (partition n step pad (nthrest s step)))
           (list (take n (concat p pad)))))))))

(defmacro declare [& names]
  `(do ~@(map (fn [n] (list 'def n)) names)))

(defmacro loop [flat & body]
  (let [bindings (partition 2 flat)]
    `((fn ~(vec (map first bindings)) ~@body) ~@(vec (map (fn [x] (first (rest x))) bindings)))))

(defn refer-timl []
  (refer 'timl.core))
(defmacro ns [name]
  `(do
     (in-ns '~name)
     (refer-timl)))

(defn ns-resolve
  ([ns sym] (#*timl#namespace#maybe_resolve ns sym))
  ([ns env sym] (if (contains? (:locals env) sym) nil (ns-resolve ns sym))))

(defn resolve
  ([sym] (ns-resolve *ns* sym))
  ([env sym] (ns-resolve *ns* env sym)))

(defmacro defmethod [name type & body]
  `(#*timl#type#define_method *ns* '~name ~(symbol (. (resolve type) str)) (fn ~@body)))

(load "core_macros")
(load "core_basics")
(load "core_seq")
(load "core_coll")
(load "core_ref")
(load "core_vim")
